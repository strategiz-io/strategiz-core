package io.strategiz.business.historicalinsights.model;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.fasterxml.jackson.annotation.JsonProperty;

/**
 * Comprehensive historical insights for a symbol, generated by analyzing years of market data.
 * This class aggregates volatility, indicator effectiveness, market characteristics, and risk
 * insights to help generate data-driven trading strategies using Historical Market Insights (Autonomous AI mode).
 */
public class SymbolInsights {

	private String symbol;

	private String timeframe;

	private int daysAnalyzed;

	// Volatility insights
	private double avgVolatility; // 14-day ATR average

	private String volatilityRegime; // LOW, MEDIUM, HIGH, EXTREME

	private double avgDailyRange; // (high - low) / close percentage

	// Top-ranked indicators (by historical effectiveness)
	@JsonProperty("topIndicators")
	private List<IndicatorRanking> topIndicators;

	// Optimal parameters discovered through grid search
	@JsonProperty("optimalParameters")
	private Map<String, Object> optimalParameters;

	// Market characteristics
	private String trendDirection; // BULLISH, BEARISH, SIDEWAYS

	private double trendStrength; // 0.0 - 1.0

	@JsonProperty("isMeanReverting")
	private boolean isMeanReverting; // Hurst exponent < 0.5

	// Risk insights
	private double avgMaxDrawdown; // Historical average maximum drawdown %

	private double avgWinRate; // Historical average win rate %

	private String recommendedRiskLevel; // LOW, MEDIUM, HIGH

	// Optional fundamentals (if requested)
	private FundamentalsInsights fundamentals;

	// Major price turning points (peaks and troughs) for Autonomous AI hindsight
	@JsonProperty("turningPoints")
	private List<PriceTurningPoint> turningPoints;

	// === ADVANCED STATISTICS (Phase 1 Enhancement) ===

	// Swing cycle statistics
	private double avgSwingMagnitude; // Average % move between turning points

	private double medianSwingMagnitude;

	private int avgSwingDuration; // Average days between turning points

	private int optimalHoldingPeriodDays;

	private double optimalHoldingWinRate;

	// Hurst exponent (proper calculation via R/S analysis)
	private double hurstExponent; // <0.5 = mean-reverting, =0.5 = random, >0.5 = trending

	private String hurstInterpretation;

	// Optimal thresholds derived from turning points analysis
	private double optimalRsiOversold; // RSI value that captures 80% of historical troughs

	private double optimalRsiOverbought; // RSI value that captures 80% of historical peaks

	private double optimalPctDropForEntry; // % drop from high that captures 80% of troughs

	private double optimalPctGainForExit; // % gain that captures 80% of peaks

	// Drawdown analysis
	private double maxHistoricalDrawdown;

	private double avgDrawdown;

	private int avgDrawdownDuration;

	private int avgRecoveryDays;

	// Support/resistance levels (from clustering analysis of turning points)
	@JsonProperty("majorSupportLevels")
	private List<Double> majorSupportLevels;

	@JsonProperty("majorResistanceLevels")
	private List<Double> majorResistanceLevels;

	// Market regime classification
	private String currentRegime; // STRONG_UPTREND, UPTREND, RANGING_VOLATILE, RANGING_CALM, DOWNTREND, STRONG_DOWNTREND

	private String bestStrategyForRegime; // Recommended strategy type for current regime

	// Position sizing recommendations (based on historical volatility and win/loss)
	private double kellyCriterion; // Optimal position size based on historical win/loss ratio

	private double volatilityAdjustedSize; // Position size adjusted for current volatility

	// Multi-timeframe analysis
	@JsonProperty("mtfOverallTrend")
	private String mtfOverallTrend; // Overall trend from multi-timeframe analysis

	@JsonProperty("mtfAlignment")
	private String mtfAlignment; // FULLY_ALIGNED_BULLISH, MIXED, etc.

	@JsonProperty("mtfAlignmentScore")
	private double mtfAlignmentScore; // 0-100, higher = more aligned

	@JsonProperty("mtfTrendTimeframe")
	private String mtfTrendTimeframe; // Timeframe used for trend determination

	@JsonProperty("mtfEntryTimeframe")
	private String mtfEntryTimeframe; // Optimal timeframe for entry timing

	@JsonProperty("mtfRecommendations")
	private List<String> mtfRecommendations; // Trading recommendations from MTF analysis

	public SymbolInsights() {
		this.topIndicators = new ArrayList<>();
		this.optimalParameters = new HashMap<>();
		this.turningPoints = new ArrayList<>();
		this.majorSupportLevels = new ArrayList<>();
		this.majorResistanceLevels = new ArrayList<>();
	}

	// Getters and setters

	public String getSymbol() {
		return symbol;
	}

	public void setSymbol(String symbol) {
		this.symbol = symbol;
	}

	public String getTimeframe() {
		return timeframe;
	}

	public void setTimeframe(String timeframe) {
		this.timeframe = timeframe;
	}

	public int getDaysAnalyzed() {
		return daysAnalyzed;
	}

	public void setDaysAnalyzed(int daysAnalyzed) {
		this.daysAnalyzed = daysAnalyzed;
	}

	public double getAvgVolatility() {
		return avgVolatility;
	}

	public void setAvgVolatility(double avgVolatility) {
		this.avgVolatility = avgVolatility;
	}

	public String getVolatilityRegime() {
		return volatilityRegime;
	}

	public void setVolatilityRegime(String volatilityRegime) {
		this.volatilityRegime = volatilityRegime;
	}

	public double getAvgDailyRange() {
		return avgDailyRange;
	}

	public void setAvgDailyRange(double avgDailyRange) {
		this.avgDailyRange = avgDailyRange;
	}

	public List<IndicatorRanking> getTopIndicators() {
		return topIndicators;
	}

	public void setTopIndicators(List<IndicatorRanking> topIndicators) {
		this.topIndicators = topIndicators;
	}

	public Map<String, Object> getOptimalParameters() {
		return optimalParameters;
	}

	public void setOptimalParameters(Map<String, Object> optimalParameters) {
		this.optimalParameters = optimalParameters;
	}

	public String getTrendDirection() {
		return trendDirection;
	}

	public void setTrendDirection(String trendDirection) {
		this.trendDirection = trendDirection;
	}

	public double getTrendStrength() {
		return trendStrength;
	}

	public void setTrendStrength(double trendStrength) {
		this.trendStrength = trendStrength;
	}

	public boolean isMeanReverting() {
		return isMeanReverting;
	}

	public void setMeanReverting(boolean meanReverting) {
		isMeanReverting = meanReverting;
	}

	public double getAvgMaxDrawdown() {
		return avgMaxDrawdown;
	}

	public void setAvgMaxDrawdown(double avgMaxDrawdown) {
		this.avgMaxDrawdown = avgMaxDrawdown;
	}

	public double getAvgWinRate() {
		return avgWinRate;
	}

	public void setAvgWinRate(double avgWinRate) {
		this.avgWinRate = avgWinRate;
	}

	public String getRecommendedRiskLevel() {
		return recommendedRiskLevel;
	}

	public void setRecommendedRiskLevel(String recommendedRiskLevel) {
		this.recommendedRiskLevel = recommendedRiskLevel;
	}

	public FundamentalsInsights getFundamentals() {
		return fundamentals;
	}

	public void setFundamentals(FundamentalsInsights fundamentals) {
		this.fundamentals = fundamentals;
	}

	public List<PriceTurningPoint> getTurningPoints() {
		return turningPoints;
	}

	public void setTurningPoints(List<PriceTurningPoint> turningPoints) {
		this.turningPoints = turningPoints;
	}

	// === ADVANCED STATISTICS GETTERS/SETTERS ===

	public double getAvgSwingMagnitude() {
		return avgSwingMagnitude;
	}

	public void setAvgSwingMagnitude(double avgSwingMagnitude) {
		this.avgSwingMagnitude = avgSwingMagnitude;
	}

	public double getMedianSwingMagnitude() {
		return medianSwingMagnitude;
	}

	public void setMedianSwingMagnitude(double medianSwingMagnitude) {
		this.medianSwingMagnitude = medianSwingMagnitude;
	}

	public int getAvgSwingDuration() {
		return avgSwingDuration;
	}

	public void setAvgSwingDuration(int avgSwingDuration) {
		this.avgSwingDuration = avgSwingDuration;
	}

	public int getOptimalHoldingPeriodDays() {
		return optimalHoldingPeriodDays;
	}

	public void setOptimalHoldingPeriodDays(int optimalHoldingPeriodDays) {
		this.optimalHoldingPeriodDays = optimalHoldingPeriodDays;
	}

	public double getOptimalHoldingWinRate() {
		return optimalHoldingWinRate;
	}

	public void setOptimalHoldingWinRate(double optimalHoldingWinRate) {
		this.optimalHoldingWinRate = optimalHoldingWinRate;
	}

	public double getHurstExponent() {
		return hurstExponent;
	}

	public void setHurstExponent(double hurstExponent) {
		this.hurstExponent = hurstExponent;
	}

	public String getHurstInterpretation() {
		return hurstInterpretation;
	}

	public void setHurstInterpretation(String hurstInterpretation) {
		this.hurstInterpretation = hurstInterpretation;
	}

	public double getOptimalRsiOversold() {
		return optimalRsiOversold;
	}

	public void setOptimalRsiOversold(double optimalRsiOversold) {
		this.optimalRsiOversold = optimalRsiOversold;
	}

	public double getOptimalRsiOverbought() {
		return optimalRsiOverbought;
	}

	public void setOptimalRsiOverbought(double optimalRsiOverbought) {
		this.optimalRsiOverbought = optimalRsiOverbought;
	}

	public double getOptimalPctDropForEntry() {
		return optimalPctDropForEntry;
	}

	public void setOptimalPctDropForEntry(double optimalPctDropForEntry) {
		this.optimalPctDropForEntry = optimalPctDropForEntry;
	}

	public double getOptimalPctGainForExit() {
		return optimalPctGainForExit;
	}

	public void setOptimalPctGainForExit(double optimalPctGainForExit) {
		this.optimalPctGainForExit = optimalPctGainForExit;
	}

	public double getMaxHistoricalDrawdown() {
		return maxHistoricalDrawdown;
	}

	public void setMaxHistoricalDrawdown(double maxHistoricalDrawdown) {
		this.maxHistoricalDrawdown = maxHistoricalDrawdown;
	}

	public double getAvgDrawdown() {
		return avgDrawdown;
	}

	public void setAvgDrawdown(double avgDrawdown) {
		this.avgDrawdown = avgDrawdown;
	}

	public int getAvgDrawdownDuration() {
		return avgDrawdownDuration;
	}

	public void setAvgDrawdownDuration(int avgDrawdownDuration) {
		this.avgDrawdownDuration = avgDrawdownDuration;
	}

	public int getAvgRecoveryDays() {
		return avgRecoveryDays;
	}

	public void setAvgRecoveryDays(int avgRecoveryDays) {
		this.avgRecoveryDays = avgRecoveryDays;
	}

	public List<Double> getMajorSupportLevels() {
		return majorSupportLevels;
	}

	public void setMajorSupportLevels(List<Double> majorSupportLevels) {
		this.majorSupportLevels = majorSupportLevels;
	}

	public List<Double> getMajorResistanceLevels() {
		return majorResistanceLevels;
	}

	public void setMajorResistanceLevels(List<Double> majorResistanceLevels) {
		this.majorResistanceLevels = majorResistanceLevels;
	}

	public String getCurrentRegime() {
		return currentRegime;
	}

	public void setCurrentRegime(String currentRegime) {
		this.currentRegime = currentRegime;
	}

	public String getBestStrategyForRegime() {
		return bestStrategyForRegime;
	}

	public void setBestStrategyForRegime(String bestStrategyForRegime) {
		this.bestStrategyForRegime = bestStrategyForRegime;
	}

	public double getKellyCriterion() {
		return kellyCriterion;
	}

	public void setKellyCriterion(double kellyCriterion) {
		this.kellyCriterion = kellyCriterion;
	}

	public double getVolatilityAdjustedSize() {
		return volatilityAdjustedSize;
	}

	public void setVolatilityAdjustedSize(double volatilityAdjustedSize) {
		this.volatilityAdjustedSize = volatilityAdjustedSize;
	}

	public String getMtfOverallTrend() {
		return mtfOverallTrend;
	}

	public void setMtfOverallTrend(String mtfOverallTrend) {
		this.mtfOverallTrend = mtfOverallTrend;
	}

	public String getMtfAlignment() {
		return mtfAlignment;
	}

	public void setMtfAlignment(String mtfAlignment) {
		this.mtfAlignment = mtfAlignment;
	}

	public double getMtfAlignmentScore() {
		return mtfAlignmentScore;
	}

	public void setMtfAlignmentScore(double mtfAlignmentScore) {
		this.mtfAlignmentScore = mtfAlignmentScore;
	}

	public String getMtfTrendTimeframe() {
		return mtfTrendTimeframe;
	}

	public void setMtfTrendTimeframe(String mtfTrendTimeframe) {
		this.mtfTrendTimeframe = mtfTrendTimeframe;
	}

	public String getMtfEntryTimeframe() {
		return mtfEntryTimeframe;
	}

	public void setMtfEntryTimeframe(String mtfEntryTimeframe) {
		this.mtfEntryTimeframe = mtfEntryTimeframe;
	}

	public List<String> getMtfRecommendations() {
		return mtfRecommendations;
	}

	public void setMtfRecommendations(List<String> mtfRecommendations) {
		this.mtfRecommendations = mtfRecommendations;
	}

	/**
	 * Formats the insights into a human-readable summary suitable for AI prompt enhancement.
	 * This method is called by the AIStrategyService to inject historical context into the
	 * generation prompt.
	 * @return Formatted string with all insights
	 */
	public String toAIPromptFormat() {
		StringBuilder sb = new StringBuilder();

		sb.append(String.format("Symbol: %s | Timeframe: %s | Period: %d days (%.1f years)\n\n", symbol, timeframe,
				daysAnalyzed, daysAnalyzed / 365.25));

		// === MARKET REGIME (Most Important) ===
		sb.append("## MARKET REGIME: ").append(currentRegime != null ? currentRegime : "UNKNOWN");
		if (hurstExponent > 0) {
			sb.append(String.format(" (Hurst: %.2f)", hurstExponent));
		}
		sb.append("\n");

		// Regime implications
		if (isMeanReverting) {
			sb.append("→ IMPLICATION: Market shows mean-reverting behavior\n");
			sb.append("→ IMPLICATION: Oscillator strategies (RSI, Stochastic) likely profitable\n");
			sb.append("→ IMPLICATION: Avoid trend-following strategies - will whipsaw\n");
		}
		else {
			sb.append("→ IMPLICATION: Market shows trending behavior\n");
			sb.append("→ IMPLICATION: Momentum strategies (MACD, MA crossovers) recommended\n");
			sb.append("→ IMPLICATION: Mean-reversion strategies may underperform\n");
		}

		if (bestStrategyForRegime != null) {
			sb.append(String.format("→ RECOMMENDED STRATEGY: %s\n", bestStrategyForRegime));
		}
		sb.append("\n");

		// === MULTI-TIMEFRAME ANALYSIS ===
		if (mtfOverallTrend != null && mtfAlignment != null) {
			sb.append("## MULTI-TIMEFRAME ANALYSIS\n");
			sb.append(String.format("- Overall Trend: %s\n", mtfOverallTrend));
			sb.append(String.format("- Timeframe Alignment: %s (%.0f%% aligned)\n", mtfAlignment, mtfAlignmentScore));
			if (mtfTrendTimeframe != null) {
				sb.append(String.format("- Trend Timeframe: %s (use for direction)\n", mtfTrendTimeframe));
			}
			if (mtfEntryTimeframe != null) {
				sb.append(String.format("- Entry Timeframe: %s (use for timing)\n", mtfEntryTimeframe));
			}

			// MTF Implications
			if (mtfAlignmentScore >= 80) {
				sb.append("→ IMPLICATION: High alignment - strong conviction in trend direction\n");
				sb.append("→ IMPLICATION: Can use larger position sizes\n");
			}
			else if (mtfAlignmentScore >= 50) {
				sb.append("→ IMPLICATION: Moderate alignment - use standard position sizes\n");
				sb.append("→ IMPLICATION: Wait for lower timeframe to align before entry\n");
			}
			else {
				sb.append("→ IMPLICATION: Low alignment - reduce position size\n");
				sb.append("→ IMPLICATION: Consider mean-reversion instead of trend-following\n");
			}

			if (mtfRecommendations != null && !mtfRecommendations.isEmpty()) {
				sb.append("### MTF Recommendations:\n");
				for (String rec : mtfRecommendations.subList(0, Math.min(3, mtfRecommendations.size()))) {
					sb.append(String.format("  → %s\n", rec));
				}
			}
			sb.append("\n");
		}

		// === OPTIMAL THRESHOLDS (Derived from Historical Analysis) ===
		if (turningPoints != null && turningPoints.size() > 5) {
			int troughCount = (int) turningPoints.stream()
				.filter(tp -> tp.getType() == PriceTurningPoint.PointType.TROUGH)
				.count();
			int peakCount = turningPoints.size() - troughCount;

			sb.append(String.format("## OPTIMAL ENTRY THRESHOLDS (from %d historical troughs):\n", troughCount));
			if (optimalRsiOversold > 0) {
				sb.append(String.format("- RSI below %.1f captures 80%% of optimal buy points\n", optimalRsiOversold));
			}
			if (optimalPctDropForEntry > 0) {
				sb.append(String.format("- Price drop of %.1f%% from high captures 80%% of entries\n",
						optimalPctDropForEntry));
			}
			sb.append(String.format("→ RECOMMENDATION: Enter when RSI < %.1f\n\n", optimalRsiOversold));

			sb.append(String.format("## OPTIMAL EXIT THRESHOLDS (from %d historical peaks):\n", peakCount));
			if (optimalRsiOverbought > 0) {
				sb.append(
						String.format("- RSI above %.1f captures 80%% of optimal sell points\n", optimalRsiOverbought));
			}
			if (optimalPctGainForExit > 0) {
				sb.append(String.format("- Price gain of %.1f%% captures 80%% of exits\n", optimalPctGainForExit));
			}
			sb.append(String.format("→ RECOMMENDATION: Exit when RSI > %.1f OR use trailing stop\n\n",
					optimalRsiOverbought));
		}

		// === SWING CYCLE STATISTICS ===
		if (avgSwingMagnitude > 0) {
			sb.append("## SWING CYCLE ANALYSIS:\n");
			sb.append(String.format("- Average swing magnitude: %.1f%%\n", avgSwingMagnitude));
			sb.append(String.format("- Median swing magnitude: %.1f%%\n", medianSwingMagnitude));
			sb.append(String.format("- Average swing duration: %d days\n", avgSwingDuration));
			sb.append(String.format("- Optimal holding period: %d days (%.0f%% win rate)\n", optimalHoldingPeriodDays,
					optimalHoldingWinRate * 100));
			sb.append("→ IMPLICATION: Plan trades around these typical swing characteristics\n\n");
		}

		// === DRAWDOWN ANALYSIS ===
		if (maxHistoricalDrawdown > 0) {
			sb.append("## DRAWDOWN ANALYSIS:\n");
			sb.append(String.format("- Maximum historical drawdown: %.1f%%\n", maxHistoricalDrawdown));
			sb.append(String.format("- Average drawdown: %.1f%%\n", avgDrawdown));
			sb.append(String.format("- Average drawdown duration: %d days\n", avgDrawdownDuration));
			sb.append(String.format("- Average recovery time: %d days\n", avgRecoveryDays));
			sb.append(String.format("→ RECOMMENDATION: Set stop loss no tighter than %.1f%% (avg drawdown)\n\n",
					avgDrawdown));
		}

		// === POSITION SIZING ===
		if (kellyCriterion > 0) {
			sb.append("## POSITION SIZING RECOMMENDATIONS:\n");
			sb.append(String.format("- Quarter-Kelly position size: %.1f%% of portfolio\n", kellyCriterion * 100));
			sb.append(String.format("- Volatility-adjusted size: %.1f%% of portfolio\n", volatilityAdjustedSize * 100));
			sb.append("→ RECOMMENDATION: Use the smaller of these two values\n\n");
		}

		// === SUPPORT/RESISTANCE LEVELS ===
		if (majorSupportLevels != null && !majorSupportLevels.isEmpty()) {
			sb.append("## KEY PRICE LEVELS:\n");
			sb.append("Support levels: ");
			for (int i = 0; i < Math.min(3, majorSupportLevels.size()); i++) {
				sb.append(String.format("$%.2f", majorSupportLevels.get(i)));
				if (i < Math.min(3, majorSupportLevels.size()) - 1) {
					sb.append(", ");
				}
			}
			sb.append("\n");
		}
		if (majorResistanceLevels != null && !majorResistanceLevels.isEmpty()) {
			sb.append("Resistance levels: ");
			for (int i = 0; i < Math.min(3, majorResistanceLevels.size()); i++) {
				sb.append(String.format("$%.2f", majorResistanceLevels.get(i)));
				if (i < Math.min(3, majorResistanceLevels.size()) - 1) {
					sb.append(", ");
				}
			}
			sb.append("\n\n");
		}

		// === VOLATILITY PROFILE ===
		sb.append("## VOLATILITY PROFILE:\n");
		sb.append(String.format("- Regime: %s\n", volatilityRegime));
		sb.append(String.format("- Avg ATR: $%.2f\n", avgVolatility));
		sb.append(String.format("- Avg Daily Range: %.2f%%\n\n", avgDailyRange));

		// === TOP INDICATORS (if available) ===
		if (topIndicators != null && !topIndicators.isEmpty()) {
			sb.append("## TOP PERFORMING INDICATORS:\n");
			for (int i = 0; i < Math.min(5, topIndicators.size()); i++) {
				IndicatorRanking ranking = topIndicators.get(i);
				sb.append(String.format("%d. %s (Score: %.2f) - %s\n", i + 1, ranking.getIndicatorName(),
						ranking.getEffectivenessScore(), ranking.getReason()));
			}
			sb.append("\n");
		}

		// === MARKET CHARACTERISTICS ===
		sb.append("## MARKET CHARACTERISTICS:\n");
		sb.append(String.format("- Trend: %s (Strength: %.0f%%)\n", trendDirection, trendStrength * 100));
		sb.append(String.format("- Type: %s (Hurst: %.2f)\n", isMeanReverting ? "Mean-Reverting" : "Trending",
				hurstExponent));
		if (hurstInterpretation != null) {
			sb.append(String.format("- Hurst Interpretation: %s\n", hurstInterpretation));
		}
		sb.append("\n");

		// === RISK INSIGHTS ===
		sb.append("## RISK INSIGHTS:\n");
		sb.append(String.format("- Avg Win Rate: %.1f%%\n", avgWinRate));
		sb.append(String.format("- Avg Max Drawdown: %.1f%%\n", avgMaxDrawdown));
		sb.append(String.format("- Recommended Risk Level: %s\n", recommendedRiskLevel));

		return sb.toString();
	}

}
