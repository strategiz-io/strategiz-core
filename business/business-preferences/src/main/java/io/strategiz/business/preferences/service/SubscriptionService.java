package io.strategiz.business.preferences.service;

import io.strategiz.data.preferences.entity.SubscriptionTier;
import io.strategiz.data.preferences.entity.UserSubscription;
import io.strategiz.data.preferences.repository.SubscriptionRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Service for managing user subscriptions and usage limits.
 */
@Service
public class SubscriptionService {

	private static final Logger logger = LoggerFactory.getLogger(SubscriptionService.class);

	private final SubscriptionRepository repository;

	public SubscriptionService(SubscriptionRepository repository) {
		this.repository = repository;
	}

	/**
	 * Get subscription for a user.
	 * @param userId The user ID
	 * @return The user subscription
	 */
	public UserSubscription getSubscription(String userId) {
		logger.debug("Getting subscription for user {}", userId);
		return repository.getByUserId(userId);
	}

	/**
	 * Get the subscription tier for a user.
	 * @param userId The user ID
	 * @return The subscription tier
	 */
	public SubscriptionTier getTier(String userId) {
		return repository.getTier(userId);
	}

	/**
	 * Check if a model is allowed for the user's subscription tier.
	 * @param userId The user ID
	 * @param modelId The model ID
	 * @return true if the model is allowed
	 */
	public boolean isModelAllowed(String userId, String modelId) {
		SubscriptionTier tier = getTier(userId);
		boolean allowed = tier.isModelAllowed(modelId);
		if (!allowed) {
			logger.info("Model {} not allowed for user {} on tier {}", modelId, userId, tier.getId());
		}
		return allowed;
	}

	/**
	 * Get allowed models for a user's subscription tier.
	 * @param userId The user ID
	 * @return List of allowed model IDs
	 */
	public List<String> getAllowedModels(String userId) {
		return getTier(userId).getAllowedModels();
	}

	/**
	 * Check if user can send a message (within daily limit).
	 * @param userId The user ID
	 * @return true if within limit
	 */
	public boolean canSendMessage(String userId) {
		UserSubscription sub = getSubscription(userId);
		SubscriptionTier tier = sub.getTierEnum();

		if (tier.hasUnlimitedMessages()) {
			return true;
		}

		return sub.getDailyMessagesUsed() < tier.getDailyMessageLimit();
	}

	/**
	 * Check if user can generate a strategy (within daily limit).
	 * @param userId The user ID
	 * @return true if within limit
	 */
	public boolean canGenerateStrategy(String userId) {
		UserSubscription sub = getSubscription(userId);
		SubscriptionTier tier = sub.getTierEnum();

		if (tier.hasUnlimitedStrategies()) {
			return true;
		}

		return sub.getDailyStrategiesUsed() < tier.getDailyStrategyLimit();
	}

	/**
	 * Record a message sent by the user.
	 * @param userId The user ID
	 * @return The updated subscription
	 */
	public UserSubscription recordMessageUsage(String userId) {
		logger.debug("Recording message usage for user {}", userId);
		return repository.incrementMessageUsage(userId);
	}

	/**
	 * Record a strategy generated by the user.
	 * @param userId The user ID
	 * @return The updated subscription
	 */
	public UserSubscription recordStrategyUsage(String userId) {
		logger.debug("Recording strategy usage for user {}", userId);
		return repository.incrementStrategyUsage(userId);
	}

	/**
	 * Get remaining messages for the day.
	 * @param userId The user ID
	 * @return Remaining messages (-1 for unlimited)
	 */
	public int getRemainingMessages(String userId) {
		UserSubscription sub = getSubscription(userId);
		SubscriptionTier tier = sub.getTierEnum();

		if (tier.hasUnlimitedMessages()) {
			return -1;
		}

		return Math.max(0, tier.getDailyMessageLimit() - sub.getDailyMessagesUsed());
	}

	/**
	 * Get remaining strategies for the day.
	 * @param userId The user ID
	 * @return Remaining strategies (-1 for unlimited)
	 */
	public int getRemainingStrategies(String userId) {
		UserSubscription sub = getSubscription(userId);
		SubscriptionTier tier = sub.getTierEnum();

		if (tier.hasUnlimitedStrategies()) {
			return -1;
		}

		return Math.max(0, tier.getDailyStrategyLimit() - sub.getDailyStrategiesUsed());
	}

	/**
	 * Update subscription (for Stripe webhook handling).
	 * @param userId The user ID
	 * @param subscription The updated subscription
	 * @return The saved subscription
	 */
	public UserSubscription updateSubscription(String userId, UserSubscription subscription) {
		logger.info("Updating subscription for user {} to tier {}", userId, subscription.getTier());
		return repository.save(userId, subscription);
	}

	/**
	 * Upgrade user to a new tier.
	 * @param userId The user ID
	 * @param newTier The new tier
	 * @return The updated subscription
	 */
	public UserSubscription upgradeTier(String userId, SubscriptionTier newTier) {
		logger.info("Upgrading user {} to tier {}", userId, newTier.getId());
		return repository.updateTier(userId, newTier);
	}

	/**
	 * Cancel subscription (set to cancel at period end).
	 * @param userId The user ID
	 * @return The updated subscription
	 */
	public UserSubscription cancelSubscription(String userId) {
		logger.info("Canceling subscription for user {}", userId);
		UserSubscription sub = getSubscription(userId);
		sub.setCancelAtPeriodEnd(true);
		return repository.save(userId, sub);
	}

	/**
	 * Get all available tiers with their details.
	 * @return List of all tiers
	 */
	public List<TierInfo> getAllTiers() {
		return Arrays.stream(SubscriptionTier.values()).map(tier -> new TierInfo(tier.getId(), tier.getDisplayName(),
				tier.getPriceInCents(), tier.getDescription(), tier.getAllowedModels(), tier.getDailyMessageLimit(),
				tier.getDailyStrategyLimit())).collect(Collectors.toList());
	}

	/**
	 * DTO for tier information.
	 */
	public record TierInfo(String id, String name, int priceInCents, String description, List<String> allowedModels,
			int dailyMessageLimit, int dailyStrategyLimit) {
	}

}
