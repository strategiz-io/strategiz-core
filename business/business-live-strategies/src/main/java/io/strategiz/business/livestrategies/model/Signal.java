package io.strategiz.business.livestrategies.model;

import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

/**
 * Represents a trading signal generated by strategy execution. Contains the signal type
 * (BUY/SELL/HOLD) and associated metadata.
 */
public class Signal {

	/**
	 * Signal types
	 */
	public enum Type {

		BUY, SELL, HOLD

	}

	private final String deploymentId;

	private final String deploymentType; // "ALERT" or "BOT"

	private final Type type;

	private final String symbol;

	private final double price;

	private final Map<String, Double> indicators;

	private final Instant timestamp;

	private final String strategyId;

	private Signal(Builder builder) {
		this.deploymentId = builder.deploymentId;
		this.deploymentType = builder.deploymentType;
		this.type = builder.type;
		this.symbol = builder.symbol;
		this.price = builder.price;
		this.indicators = builder.indicators != null ? new HashMap<>(builder.indicators) : new HashMap<>();
		this.timestamp = builder.timestamp != null ? builder.timestamp : Instant.now();
		this.strategyId = builder.strategyId;
	}

	public static Builder builder() {
		return new Builder();
	}

	public String getDeploymentId() {
		return deploymentId;
	}

	public String getDeploymentType() {
		return deploymentType;
	}

	public Type getType() {
		return type;
	}

	public String getSymbol() {
		return symbol;
	}

	public double getPrice() {
		return price;
	}

	public Map<String, Double> getIndicators() {
		return new HashMap<>(indicators);
	}

	public Instant getTimestamp() {
		return timestamp;
	}

	public String getStrategyId() {
		return strategyId;
	}

	public boolean isBuy() {
		return type == Type.BUY;
	}

	public boolean isSell() {
		return type == Type.SELL;
	}

	public boolean isHold() {
		return type == Type.HOLD;
	}

	public boolean isActionable() {
		return type != Type.HOLD;
	}

	public boolean isAlertSignal() {
		return "ALERT".equals(deploymentType);
	}

	public boolean isBotSignal() {
		return "BOT".equals(deploymentType);
	}

	@Override
	public String toString() {
		return String.format("Signal[%s %s @ %.2f for deployment=%s, strategy=%s]", type, symbol, price, deploymentId,
				strategyId);
	}

	public static class Builder {

		private String deploymentId;

		private String deploymentType;

		private Type type;

		private String symbol;

		private double price;

		private Map<String, Double> indicators;

		private Instant timestamp;

		private String strategyId;

		public Builder deploymentId(String deploymentId) {
			this.deploymentId = deploymentId;
			return this;
		}

		public Builder deploymentType(String deploymentType) {
			this.deploymentType = deploymentType;
			return this;
		}

		public Builder type(Type type) {
			this.type = type;
			return this;
		}

		public Builder type(String typeStr) {
			this.type = Type.valueOf(typeStr.toUpperCase());
			return this;
		}

		public Builder symbol(String symbol) {
			this.symbol = symbol;
			return this;
		}

		public Builder price(double price) {
			this.price = price;
			return this;
		}

		public Builder indicators(Map<String, Double> indicators) {
			this.indicators = indicators;
			return this;
		}

		public Builder addIndicator(String name, double value) {
			if (this.indicators == null) {
				this.indicators = new HashMap<>();
			}
			this.indicators.put(name, value);
			return this;
		}

		public Builder timestamp(Instant timestamp) {
			this.timestamp = timestamp;
			return this;
		}

		public Builder strategyId(String strategyId) {
			this.strategyId = strategyId;
			return this;
		}

		public Signal build() {
			if (deploymentId == null || type == null || symbol == null) {
				throw new IllegalStateException("deploymentId, type, and symbol are required");
			}
			return new Signal(this);
		}

	}

}
