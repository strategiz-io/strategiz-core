package io.strategiz.coinbase.controller;

// Never use mock data - always use real API data

import io.strategiz.coinbase.client.exception.CoinbaseApiException;
import io.strategiz.coinbase.service.CoinbaseService;
import io.strategiz.coinbase.service.firestore.FirestoreService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.client.HttpStatusCodeException;
import org.springframework.web.client.RestClientResponseException;
import org.springframework.web.client.RestTemplate;

import javax.servlet.http.HttpServletRequest;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import com.google.firebase.cloud.FirestoreClient;
import com.google.cloud.firestore.QuerySnapshot;
import org.slf4j.MDC;

/**
 * Controller for Coinbase admin operations
 */
@RestController
@RequestMapping("/api/coinbase")
@Slf4j
public class CoinbaseAdminController {

    @Autowired
    private CoinbaseService coinbaseService;
    
    @Autowired
    @Qualifier("coinbaseFirestoreService")
    private FirestoreService firestoreService;
    
    private final RestTemplate restTemplate = new RestTemplate();
    
    /**
     * Health check endpoint for Coinbase API integration
     * This verifies that the API controller is responding and attempts to check connectivity to Coinbase
     * using real credentials (never mock data)
     * 
     * @param httpRequest HTTP request
     * @return Health status
     */
    @GetMapping("/health")
    @CrossOrigin(origins = {"http://localhost:3000", "https://strategiz.io"}, allowedHeaders = "*")
    public ResponseEntity<Map<String, Object>> healthCheck(HttpServletRequest httpRequest) {
        log.info("Received health check request");
        
        Map<String, Object> response = new HashMap<>();
        response.put("status", "up");
        response.put("controller", "CoinbaseAdminController");
        response.put("timestamp", new Date().toString());
        
        try {
            String userId = httpRequest.getHeader("X-User-Email");
            if (userId == null || userId.isEmpty()) {
                userId = httpRequest.getParameter("email");
            }
            
            if (userId != null && !userId.isEmpty()) {
                // If we have a user ID, try to get their API credentials
                Map<String, String> credentials = firestoreService.getCoinbaseCredentials(userId);
                
                if (credentials != null && !credentials.isEmpty()) {
                    // Check if API credentials are valid by checking if they exist
                    String apiKey = credentials.get("apiKey");
                    String privateKey = credentials.get("privateKey");
                    String passphrase = credentials.get("passphrase");
                    
                    if (apiKey != null && !apiKey.isEmpty() && privateKey != null && !privateKey.isEmpty() && passphrase != null && !passphrase.isEmpty()) {
                        try {
                            boolean connected = coinbaseService.testConnection(apiKey, privateKey, passphrase);
                            response.put("configuredForUser", true);
                            response.put("userEmail", userId);
                            response.put("hasApiKey", true);
                            response.put("hasPrivateKey", true);
                            response.put("hasPassphrase", true);
                            response.put("coinbaseApiConnected", connected);
                        } catch (CoinbaseApiException e) {
                            log.error("Error testing Coinbase API connection: {}", e.getMessage(), e);
                            response.put("configuredForUser", true);
                            response.put("userEmail", userId);
                            response.put("hasApiKey", true);
                            response.put("hasPrivateKey", true);
                            response.put("hasPassphrase", true);
                            response.put("coinbaseApiConnected", false);
                            response.put("coinbaseApiError", e.getMessage());
                        }
                    } else {
                        response.put("configuredForUser", false);
                        response.put("userEmail", userId);
                    }
                } else {
                    response.put("configuredForUser", false);
                    response.put("userEmail", userId);
                }
            }
            
            // Check if Coinbase API is available by making a public endpoint call
            try {
                // Use a public endpoint that doesn't require authentication
                ResponseEntity<Object> publicApiResponse = restTemplate.getForEntity(
                    "https://api.coinbase.com/v2/currencies", Object.class);
                
                if (publicApiResponse.getStatusCode().is2xxSuccessful()) {
                    response.put("coinbaseApiAvailable", true);
                } else {
                    response.put("coinbaseApiAvailable", false);
                    response.put("coinbaseApiError", "Non-200 response: " + publicApiResponse.getStatusCode());
                }
            } catch (RestClientResponseException e) {
                response.put("coinbaseApiAvailable", false);
                response.put("coinbaseApiError", e.getMessage());
            } catch (Exception e) {
                response.put("coinbaseApiAvailable", false);
                response.put("coinbaseApiError", e.getMessage());
            }
            
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("Error in health check: {}", e.getMessage(), e);
            response.put("error", e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }

    /**
     * Get raw account data from Coinbase API - dedicated endpoint for frontend
     * This endpoint returns the completely unmodified raw data from Coinbase API
     * 
     * @param httpRequest HTTP request
     * @return Raw account data from Coinbase API
     */
    @GetMapping("/raw-account-data")
    @CrossOrigin(origins = {"http://localhost:3000", "https://strategiz.io"}, allowedHeaders = "*")
    public ResponseEntity<Object> getRawAccountDataForFrontend(HttpServletRequest httpRequest) {
        String requestId = String.valueOf(System.currentTimeMillis());
        MDC.put("requestId", requestId);
        log.info("[{}] Received request to get raw Coinbase account data (frontend endpoint)", requestId);
        
        try {
            String userId = httpRequest.getHeader("X-User-Email");
            if (userId == null || userId.isEmpty()) {
                log.warn("[{}] No user email provided in request header, falling back to parameter", requestId);
                userId = httpRequest.getParameter("email");
                
                if (userId == null || userId.isEmpty()) {
                    log.error("[{}] No user email provided", requestId);
                    return ResponseEntity.badRequest().body(Map.of(
                        "error", "Not Found",
                        "message", "User email is required"
                    ));
                }
            }
            
            log.info("[{}] Getting raw Coinbase account data for user: {}", requestId, userId);
            
            // Get API credentials from Firestore
            Map<String, String> credentials = firestoreService.getCoinbaseCredentials(userId);
            
            if (credentials == null || credentials.isEmpty()) {
                log.warn("[{}] Coinbase API credentials not found for user: {}", requestId, userId);
                return ResponseEntity.ok(Map.of(
                    "error", "Not Found",
                    "message", "API credentials not configured"
                ));
            }
            
            String apiKey = credentials.get("apiKey");
            String privateKey = credentials.get("privateKey");
            String passphrase = credentials.get("passphrase");
            
            // Check if we have a passphrase (required for Coinbase API)
            if (passphrase == null || passphrase.isEmpty()) {
                log.error("Missing Coinbase API passphrase for user: {}", userId);
                Map<String, Object> errorResponse = new HashMap<>();
                errorResponse.put("error", "Missing Passphrase");
                errorResponse.put("message", "Coinbase API requires a passphrase, but none was found in your stored credentials");
                errorResponse.put("timestamp", new Date().toString());
                errorResponse.put("userEmail", userId);
                errorResponse.put("credentialsFound", true); // We did find credentials but they're incomplete
                return ResponseEntity.ok(errorResponse);
            }
            
            // Get raw account data from Coinbase API
            try {
                Object rawData = coinbaseService.getRawAccountData(apiKey, privateKey, passphrase);
                
                if (rawData == null) {
                    log.error("[{}] Failed to get raw account data from Coinbase API for user: {}", requestId, userId);
                    return ResponseEntity.ok(Map.of(
                        "error", "API Error",
                        "message", "Failed to get raw account data from Coinbase API"
                    ));
                }
                
                log.info("[{}] Successfully got raw Coinbase account data for user: {}", requestId, userId);
                MDC.remove("requestId");
                return ResponseEntity.ok(rawData);
            } catch (CoinbaseApiException coinbaseError) {
                // Handle our specific Coinbase API exception which contains detailed error information
                log.error("[{}] Coinbase API error for user {}: {}", requestId, userId, coinbaseError.getMessage());
                String errorDetails = coinbaseError.getErrorDetails();
                
                Map<String, Object> errorResponse = new HashMap<>();
                errorResponse.put("error", "Coinbase API Error");
                errorResponse.put("message", "Error calling Coinbase API: " + coinbaseError.getMessage());
                errorResponse.put("coinbaseErrorDetails", errorDetails);
                errorResponse.put("timestamp", new Date().toString());
                errorResponse.put("userEmail", userId);
                errorResponse.put("credentialsFound", true);
                errorResponse.put("errorType", coinbaseError.getClass().getSimpleName());
                
                // Extract raw error details and include them directly in the response
                String rawError = coinbaseError.getErrorDetails();
                if (rawError != null && !rawError.isEmpty()) {
                    // Parse the response body if possible to include in the response
                    errorResponse.put("rawApiError", rawError);
                }
                
                // Extract HTTP status code and response body if available
                Throwable cause = coinbaseError.getCause();
                if (cause instanceof RestClientResponseException) {
                    RestClientResponseException restError = (RestClientResponseException) cause;
                    errorResponse.put("statusCode", restError.getRawStatusCode());
                    errorResponse.put("responseBody", restError.getResponseBodyAsString());
                    errorResponse.put("apiErrorMessage", restError.getMessage());
                } else if (cause instanceof HttpStatusCodeException) {
                    HttpStatusCodeException httpError = (HttpStatusCodeException) cause;
                    errorResponse.put("statusCode", httpError.getRawStatusCode());
                    errorResponse.put("responseBody", httpError.getResponseBodyAsString());
                    errorResponse.put("apiErrorMessage", httpError.getMessage());
                }
                
                // Log the complete error response to help with debugging
                log.info("[{}] Returning detailed Coinbase error response: {}", requestId, errorResponse);
                
                MDC.remove("requestId");
                return ResponseEntity.ok(errorResponse);
            } catch (Exception apiError) {
                // Fallback for any other exceptions
                log.error("[{}] General error for user {}: {}", requestId, userId, apiError.getMessage(), apiError);
                
                Map<String, Object> errorResponse = new HashMap<>();
                errorResponse.put("error", "Coinbase API Error");
                errorResponse.put("message", "Error calling Coinbase API: " + apiError.getMessage());
                errorResponse.put("timestamp", new Date().toString());
                errorResponse.put("userEmail", userId);
                errorResponse.put("credentialsFound", true);
                errorResponse.put("errorType", apiError.getClass().getSimpleName());
                
                // Log the complete error response to help with debugging
                log.info("[{}] Returning general error response: {}", requestId, errorResponse);
                
                MDC.remove("requestId");
                return ResponseEntity.ok(errorResponse);
            }
            
        } catch (Exception e) {
            log.error("[{}] Error getting raw Coinbase account data: {}", requestId, e.getMessage(), e);
            MDC.remove("requestId");
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of(
                "error", "Internal Server Error",
                "message", "Error getting raw Coinbase account data: " + e.getMessage()
            ));
        }
    }
    
    /**
     * Get Coinbase API keys
     * 
     * @param httpRequest HTTP request
     * @return API keys
     */
    @GetMapping("/api-keys")
    @CrossOrigin(origins = {"http://localhost:3000", "https://strategiz.io"}, allowedHeaders = "*")
    public ResponseEntity<Map<String, Object>> getApiKeys(HttpServletRequest httpRequest) {
        log.info("Received request to get Coinbase API keys");
        
        // Initialize result map
        Map<String, Object> result = new HashMap<>();
        
        // Get userId from request header or parameter
        String userId = httpRequest.getHeader("X-User-Email");
        if (userId == null || userId.isEmpty()) {
            userId = httpRequest.getParameter("email");
        }
        if (userId == null || userId.isEmpty()) {
            return ResponseEntity.badRequest().body(Map.of("error", "User email not provided"));
        }
        
        try {
            log.info("Using user email: '{}'", userId);
            
            log.info("Getting Coinbase API keys for user email: '{}'", userId);
            
            // Try to get credentials from FirestoreService
            Map<String, String> credentials = firestoreService.getCoinbaseCredentials(userId);
            
            if (credentials == null || credentials.isEmpty()) {
                log.warn("No Coinbase API credentials found for user: {}", userId);
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(Map.of(
                    "status", "not_found",
                    "message", "API credentials not found"
                ));
            }
            
            String apiKey = credentials.get("apiKey");
            String privateKey = credentials.get("privateKey");
            String passphrase = credentials.get("passphrase");
            
            // Validate that all required credentials are present
            if (apiKey == null || apiKey.isEmpty() || 
                privateKey == null || privateKey.isEmpty() ||
                passphrase == null || passphrase.isEmpty()) {
                
                log.warn("Incomplete Coinbase API credentials for user: {}", userId);
                return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of(
                    "status", "error",
                    "message", "API credentials incomplete or invalid. Make sure you have provided API Key, Private Key, and Passphrase."
                ));
            }
            
            // Mask the private key for security
            String maskedPrivateKey;
            if (privateKey.length() <= 8) {
                maskedPrivateKey = "********";
            } else {
                maskedPrivateKey = privateKey.substring(0, 4) + "..." + 
                    privateKey.substring(privateKey.length() - 4);
            }
            
            log.info("Retrieved Coinbase API keys for user: {}", userId);
            
            Map<String, Object> response = new HashMap<>();
            response.put("userId", userId);
            response.put("apiKey", apiKey);
            response.put("privateKey", maskedPrivateKey);
            response.put("passphrase", "[PASSPHRASE REDACTED]");
            response.put("status", "found");
            response.put("message", "API credentials retrieved successfully");
            response.put("source", "Firestore");
            
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            log.error("Error getting Coinbase API keys: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of(
                "status", "error",
                "message", "Error getting Coinbase API keys: " + e.getMessage()
            ));
        }
    }
    
    /**
     * Check API credentials in Firestore
     * This endpoint checks all possible locations where Coinbase API credentials might be stored
     * 
     * @param httpRequest HTTP request
     * @return Credential check result
     */
    @GetMapping("/api-credentials/check")
    @CrossOrigin(origins = {"http://localhost:3000", "https://strategiz.io"}, allowedHeaders = "*")
    public ResponseEntity<Map<String, Object>> checkApiCredentials(HttpServletRequest httpRequest) {
        Map<String, Object> result = new HashMap<>();
        
        // Get userId from request header or parameter
        String userId = httpRequest.getHeader("X-User-Email");
        if (userId == null || userId.isEmpty()) {
            userId = httpRequest.getParameter("email");
        }
        
        if (userId == null || userId.isEmpty()) {
            return ResponseEntity.badRequest().body(Map.of(
                "status", "error",
                "message", "User email is required"
            ));
        }
        
        result.put("userId", userId);
        
        try {
            boolean legacyPathFound = false;
            boolean providerQueryFound = false;
            boolean newPathFound = false;
            boolean legacyProviderQueryFound = false;
            
            // Try the new api_credentials subcollection with 'provider' query
            log.info("Debug: Checking api_credentials subcollection with provider=coinbase query");
            try {
                QuerySnapshot apiCredentialsQuery = FirestoreClient.getFirestore()
                    .collection("users")
                    .document(userId)
                    .collection("api_credentials")
                    .whereEqualTo("provider", "coinbase")
                    .get()
                    .get();
                providerQueryFound = !apiCredentialsQuery.isEmpty();
                result.put("providerQueryFound", providerQueryFound);
            } catch (Exception fireStoreEx) {
                log.error("Error checking api_credentials with provider query: {}", fireStoreEx.getMessage());
                result.put("apiCredentialsQueryError", fireStoreEx.getMessage());
            }
            
            // Try direct document 'coinbase' in api_credentials subcollection
            log.info("Debug: Checking api_credentials/coinbase document");
            try {
                newPathFound = FirestoreClient.getFirestore()
                    .collection("users")
                    .document(userId)
                    .collection("api_credentials")
                    .document("coinbase")
                    .get()
                    .get()
                    .exists();
                result.put("newPathFound", newPathFound);
            } catch (Exception fireStoreEx) {
                log.error("Error checking api_credentials/coinbase: {}", fireStoreEx.getMessage());
                result.put("newPathError", fireStoreEx.getMessage());
            }
            
            // Try legacy credentials subcollection with 'provider' query
            log.info("Debug: Checking legacy credentials subcollection with provider=coinbase query");
            try {
                QuerySnapshot legacyCredentialsQuery = FirestoreClient.getFirestore()
                    .collection("users")
                    .document(userId)
                    .collection("credentials")
                    .whereEqualTo("provider", "coinbase")
                    .get()
                    .get();
                legacyProviderQueryFound = !legacyCredentialsQuery.isEmpty();
                result.put("legacyProviderQueryFound", legacyProviderQueryFound);
            } catch (Exception fireStoreEx) {
                log.error("Error checking legacy credentials query: {}", fireStoreEx.getMessage());
                result.put("legacyQueryError", fireStoreEx.getMessage());
            }
            
            // Try direct document 'coinbase' in legacy credentials subcollection
            log.info("Debug: Checking credentials/coinbase document");
            try {
                legacyPathFound = FirestoreClient.getFirestore()
                    .collection("users")
                    .document(userId)
                    .collection("credentials")
                    .document("coinbase")
                    .get()
                    .get()
                    .exists();
                result.put("legacyPathFound", legacyPathFound);
            } catch (Exception fireStoreEx) {
                log.error("Error checking legacy credentials/coinbase: {}", fireStoreEx.getMessage());
                result.put("legacyPathError", fireStoreEx.getMessage());
            }
            
            // Get credentials using our FirestoreService
            try {
                Map<String, String> credentials = firestoreService.getCoinbaseCredentials(userId);
                boolean serviceFound = credentials != null && !credentials.isEmpty();
                result.put("serviceFound", serviceFound);
                
                if (serviceFound && credentials != null) { 
                    result.put("hasApiKey", credentials.get("apiKey") != null && !credentials.get("apiKey").isEmpty());
                    result.put("hasPrivateKey", credentials.get("privateKey") != null && !credentials.get("privateKey").isEmpty());
                    result.put("hasPassphrase", credentials.get("passphrase") != null && !credentials.get("passphrase").isEmpty());
                    
                    // Don't include the actual values for security reasons, just mask them to verify retrieval
                    if (credentials.containsKey("apiKey") && credentials.get("apiKey") != null) {
                        String apiKey = credentials.get("apiKey");
                        result.put("apiKeyPrefix", apiKey.substring(0, Math.min(apiKey.length(), 5)) + "...");
                    }
                }
            } catch (Exception serviceEx) {
                log.error("Error getting credentials from service: {}", serviceEx.getMessage());
                result.put("serviceError", serviceEx.getMessage());
            }
            
            log.info("Debug: Credential check result: {}", result);
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            log.error("Debug: Unexpected error checking credentials: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of(
                "error", e.getMessage(),
                "errorType", e.getClass().getName()
            ));
        }
    }
}
